\chapter{Implementation}

Here we discuss a practical implementation, \emph{spexs2}, for
pattern discovery in sequences. 

In this chapter we will discuss a practical implementation, \emph{spexs2}, for 
pattern discovery in sequences. We only discuss parts that we consider non-trivial 
or interesting and could be useful in implementing other algorithms.

Information about the full source code is in the Appendix B and C.

\section{Architecture}

The main criteria for designing program have been described in D. Parnas
paper On the Decomposition of Programs. It suggests decomposing into
isolated units and parts that are likely to change together. \cite{Parnas72}

We chose the following decomposition for the application:

\begin{small}
\begin{description}
    \itemsep-0.5em
    \item[Configuration] structure for holding the configuration data
    \item[Setup] based on the configuration initializes data-structures and functions for the algorithm
    \item[Reader] reads in the data from files
    \item[Database] a collection of datasets
    \item[Algorithm] the SPEXS2 algorithm
    \item[Printer] prints the result queries
    \item[Debugging] utilities for the program
\end{description}
\end{small}

The algorithm was decomposed based on the generalization:

\begin{small}
\begin{description}
    \itemsep-0.5em
    \item[Pattern] represents a pattern
    \item[Query] stores the pattern with database and pattern
    \item[Set] stores matching positions
    \item[Pool] stores queries
    \item[Extender] drives algorithms extending step
    \item[Feature] computes a value from a query
    \item[Filter] filters a query
\end{description}
\end{small}

\section{Configuration}

One problem with flexible algorithms is that they a lot of ways to be run.
This often leads to having tens or hundereds of program flags.
To avoid this problem we first decided to use a \emph{json} file for the program
configuration. Using \emph{json} requires exact placement of commas and quotes that
caused a lot of problems, hence we started using \emph{yaml} that is more suitable for
human input.

\todo[inline]{Short example of a configuration file.}

When running the program from command line it can be uncomfortable to
make little changes to the configuration files. In these cases a command line
flag would be much easier. To solve this problem we added markup into the 
json files so they could be replaced with a flag.

For example, inside the configuration file:

\begin{verbatim}
    "Datasets" : {
        "fore" : { "File" : "$input:main$"
        ...
\end{verbatim}

Using \emph{spexs2 --conf conf.json input=other} would replace the "File" value 
with "other". If there is no flag from command line is given, it will be replaced with "main".

\section{Input and Output}

\todo[inline]{About importance of separating the input reader and output printer from the algorithmic code}

\section{Pools}

There can be different performance characteristics when using a particular implementation. 
Most importantly to support parallelism they should be ideally lock-free,
but we can use locked version as well.

If we use a fifo queue as the in pool the algorithm does a breadth first search of patterns.
This can be problematic since we would need a lot of memory to hold all the patterns in memory.

A lifo queue for in pool is a more reasonable choice for memory problems 
since we need to hold less patterns in memory.

A priority queue suits for the output pool since we can easily then use some feature to sort 
the queue. A lock-free priority queue would be preferred, but it can be hard to get right. \todo{link to lock-free queues}

Trivial solution would be to use locks for enqueuing and dequeuing, but under high contention it
will become a bottleneck.

We know that most of the time we do not need all the results, but only the best. 
We also know that the result limit is usually several magnitudes smaller than the 
number of output candidates; this means most of the queries put into the result 
queue will be immediately discarded.

Uf the query is worse than the worst in the priority queue, it can be 
discarded immediately without doing push/pop. If we allow for that check
to fail once in a while - we can make it mostly lock-free.

\begin{algorithm}[H]
    \caption{priority queue push}
\begin{algorithmic}[1]   
    \Statef{worst \gets current~worst}
        
    \If{$ worst > new~element $}
        \Return
    \EndIf

    \Statef{acquire~lock}
    \Statef{queue.put(new~element)}
    \If{$queue.length > queue.limit$}
        \Statef{current~worst \gets queue.pop()}
    \EndIf
    \Statef{release~lock}
\end{algorithmic}
\end{algorithm}

\section{Features and Filters}

One problem is that the amount of possible filters it's useful to construct them from some other features. 
Or if we wish to use multiple filters we can combine them.

We can use these features to find out something about the query.
They each feature is defined as:

\begin{verbatim}
type Feature func(q *Query) (float64, string)
\end{verbatim}

Most of features are in $\Re$, but for some there
is some extended information that we may wish to know - hence
the need for additional string value. One of the simplest
is Pattern representation.

Also many of the features are defined in terms of multiple datasets.
We can use a closure to easily define a more generic feature.

Example:

\begin{verbatim}
func Matches(dataset []int) Feature {
    return func(q *Query) (float64, string) {
        matches := countf(q.Pos, dataset)
        return matches, ""
    }
}
\end{verbatim}

Here the Matches function creates a feature function defined
for dataset.

We can use the name in the configuration file as "Matches(fore)".

If a feature returns a floating point value we can easily turn that
into a filter by specifying a minimum or/and maximum value.

For example to give a lower and higher limits to some feature:

\begin{verbatim}
func featureFilter(feature Feature, min float64, max float64) Filter {
    return func(q *Query) bool {
        v, _ := feature(q)
        return (min <= v) && (v <= max)
    }
}
\end{verbatim}

Of course there are some filters that cannot be defined by features hence
there is still possibility to make separate filters. Such as disallowing
star symbol in the beginning of the pattern.

\section{Debugging}

Debugging is a important part of development process hence the need for 
more information how the algorithm is working.

Often this is resolved by adding some debug statments:

\begin{verbatim}
for i := 0; i < 100; i += 1{
    printf("picking")
    a := pick()
    printf("picked %v", a)

    printf("picking")
    b := pick()
    printf("picked %v", b)
    
    out.put(a + b)
}
\end{verbatim}

This can be harmful to the readability of the code. To fix this debugging problem we use closures.

\begin{verbatim}
type PickFunc func()Thing
func debuggable(fn PickFunc) PickFunc {
    return func() Thing {
        printf("start picking")
        p := fn()
        printf("picked %v" p)
        return p
    }
}

pick = debuggable(pick)
for i := 0; i < 100; i += 1{
    a := pick()
    b := pick()
    out.put(a + b)
}
\end{verbatim}

As we can see the algorithm implementation is much more readable and 
we can inject different debugging statements without actually changing the algorithm.

Also we can now change the ways how to add debug info. One of would 
be a full stepwise debugger.

\begin{verbatim}
func debuggable(fn PickFunc) PickFunc {
    return func() Thing {
        mutex.lock()
        p := fn()
        while not continue
            interact with user
        mutex.unlock()
        return p
    }
}
\end{verbatim}