\chapter{Implementation}

Here we discuss a practical implementation, \emph{spexs2}, for
pattern discovery in sequences.

The actual implementation may need to diverge from the abstract
definition for several reasons; mainly practicality, simplicity and
performance. Many of the operations can be optimized for some 
particular type of datasets and configuration.

In this chapter we will discuss parts of program that the author
considers non-trivial in it's design decisions. Information about 
the full source code is in the Appendix B and C.

\section{Algorithm}

The algorithm was implemented as:

\begin{verbatim}
type Setup struct {
	Db  *Database
	Out Pooler
	In  Pooler

	Extender Extender

	Extendable  Filter
	Outputtable Filter

	PostProcess PostProcess
}

func Run(s *Setup) {
	prepareSpexs(s)
	for {
		p, valid := s.In.Take()
		if !valid {
			return
		}

		extensions := s.Extender(p)
		for _, extended := range extensions {
			if s.Extendable(extended) {
				s.In.Put(extended)
			}
			if s.Outputtable(extended) {
				s.Out.Put(extended)
			}
		}

		if s.PostProcess(p) != nil {
			break
		}
	}
}
\end{verbatim}

Setup is a structure designed to hold the full setup of the algorithm.
The algorithm is very similar to the algorithm described in the theoretical
part, with the slight addition of PostProcess.

\section{Architecture}

The main criteria for designing program have been described in D. Parnas
paper On the Decomposition of Programs. It suggests decomposing into
isolated units and parts that are likely to change together. \cite{Parnas72}

We chose the following decomposition:

\begin{verbatim}
	Configuration
	Dataset reader
	Setup
	Algorithm
		Sets
		Pools
		Extenders
		Features
		Filters
	Printer
\end{verbatim}

This allows easily to add new data formats for input and output, 
add new query features and possible extenders.

\section{Configuration}

One problem with flexible algorithms is that they a lot of ways to be run.
This often would need having tens or hundereds of program flags.
To avoid this problem we decided to use a json file for the program
configuration.

Example Configuration.

The problem with only using a json file is that when running from
command line it may be more comfortable using flags. To solve this problem
we added replacement strings into the json files that can be given in as
a program argument.

\begin{verbatim}
	"Datasets" : {
		"fore" : { "File" : "$input$"
	...
\end{verbatim}

When using spexs2 --conf conf.json input=filename the input will be
replaced by filename. Also there is optional default value if
one wasn't given.

\section{Sets}

Since we need a collection how to store the matching positions it suggests
the need for a set datatype.

If we have predictable distribution we can pack the sets better.

Although such optimizations can be avoided if during storing pools the sets are packed using some compression algorithm.

\section{Pools}

There can be different performance characteristics when using a particular implementation. Most importantly to support parallelism they should be ideally lock-free, but we can use locked version as well.

For the pools we have several choices: lifo, fifo or priority.

If we use a fifo queue as the in pool the algorithm does a breadth first search of patterns. This can be problematic since we would need a lot of memory to hold all the patterns in memory.

A lifo queue for in pool is a more reasonable choice for memory problems since we need to hold less patterns in memory.

A priority queue suits for the out pool since we can easily then use some feature to sort the queue and choose only a limited amount. We can use a simple trick to make limited size faster. Do a precheck against the worst element in the priority queue.

\section{Features and Filters}

One problem is that the amount of possible filters it's useful to construct them from some other features. Or if we wish to use multiple filters we can combine them.

We can use these features to find out something about the query.
They each feature is defined as:

\begin{verbatim}
type Feature func(q *Query) (float64, string)
\end{verbatim}

Most of features are in $\Re$, but for some there
is some extended information that we may wish to know - hence
the need for additional string value. One of the simplest
is Pattern representation.

Also many of the features are defined in terms of multiple datasets.
We can use a closure to easily define a more generic feature.

Example:

\begin{verbatim}
func Matches(dataset []int) Feature {
	return func(q *Query) (float64, string) {
		matches := countf(q.Pos, dataset)
		return matches, ""
	}
}
\end{verbatim}

Here the Matches function creates a feature function defined
for dataset.

We can use the name in the configuration file as "Matches(fore)".

If a feature returns a floating point value we can easily turn that
into a filter by specifying a minimum or/and maximum value.

For example to give a lower and higher limits to some feature:

\begin{verbatim}
func featureFilter(feature Feature, min float64, max float64) Filter {
	return func(q *Query) bool {
		v, _ := feature(q)
		return (min <= v) && (v <= max)
	}
}
\end{verbatim}

Of course there are some filters that cannot be defined by features hence
there is still possibility to make separate filters. Such as disallowing
star symbol in the beginning of the pattern.

\section{Debugging}

Debugging is a important part of development process hence the need for more information how the algorithm is working.

Often this is resolved by adding some debug statments:

\begin{verbatim}
for i := 0; i < 100; i += 1{
	printf("picking")
	a := pick()
	printf("picked %v", a)

	printf("picking")
	b := pick()
	printf("picked %v", b)
	
	out.put(a + b)
}
\end{verbatim}

This can be harmful to the readability of the code. To fix this debugging problem we use closures.

\begin{verbatim}
type PickFunc func()Thing
func debuggable(fn PickFunc) PickFunc {
	return func() Thing {
		printf("start picking")
		p := fn()
		printf("picked %v" p)
		return p
	}
}

pick = debuggable(pick)
for i := 0; i < 100; i += 1{
	a := pick()
	b := pick()
	out.put(a + b)
}
\end{verbatim}

As we can see the algorithm implementation is much more readable and we can inject different debugging statements without actually changing the algorithm.

Also we can now change the ways how to add debug info. One of would be a full stepwise debugger.

\begin{verbatim}
func debuggable(fn PickFunc) PickFunc {
	return func() Thing {
		mutex.lock()
		p := fn()
		while not continue
			interact with user
		mutex.unlock()
		return p
	}
}
\end{verbatim}