\chapter{Implementation}
\label{c:implementation}

Here we discuss a practical implementation, \emph{spexs2}, for
pattern discovery in sequences. 

In this chapter we will discuss a practical implementation, \emph{spexs2}, for pattern discovery in sequences. We only discuss parts that we consider non-trivial or interesting and could be useful in implementing other algorithms.

Information about the full source code is in the Appendix \ref{add:spexs2}.

\section{Architecture}

The main criteria for designing program have been described in D. Parnas
paper "On the Criteria To Be Used in Decomposing Systems into Modules"\cite{Parnas72}. It suggests decomposing into isolated units and parts that are likely to change together.

We chose the following module decomposition for the application:

\begin{small}
\begin{description}
    \itemsep-0.5em
    \item[Configuration] structure for holding the configuration data
    \item[Setup] based on the configuration initializes data-structures and functions for the algorithm
    \item[Reader] reads in the data from files
    \item[Database] a collection of datasets
    \item[Algorithm] the SPEXS2 algorithm
    \item[Printer] prints the result queries
\end{description}
\end{small}

The program starts by interpreting flags, then it marshals configuration file onto an internal data structure, this configuration structure as an input to the setup module. Setup module initializes (as defined by configuration) a reader, a printer and also prepares structures for algorithm. Then the reader reads input to the database. Then the algorithm is activated and finally it is printed out with Printer.

This structure is universal for algorithm implementations and allows easily to add more configuration options, different input formats and different output formats. By changing the configuration, reader and printer we could make it a web service instead of running it on a command line.

\section{Configuration}

One problem with flexible algorithms is that there are a lot of ways to be run. This can lead to having tens or hundereds of command-line flags for the application.

To avoid this problem we decided to use a \emph{json} file for the program configuration. This format is widely known and well structured. For example a configuration file for pattern discovery in protein sequences:

\begin{lstlisting}
{
    "Dataset": {
        "fore" : { "File" : "$inp$" },
        "back" : { "File" : "$ref$" }
    },
    "Reader" : {
        "Method" : "Delimited"
    },
    "Extension": {
        "Method": "Group",
        "Groups" : {
            "." : { "elements" : "ACDEFGHIKLMNPRQSTVWY"}
        },
        "Extendable": {
            "PatGroups()" : {"max" : 3},
            "PatLength()" : {"max" : 6},
            "Matches(fore)" : {"min" : 20},
            "NoStartingGroup()" : {}
        },
        ...
    },
    "Output": {
        "SortBy": ["-Hyper(fore, back)"],
        "Count": 100
    },
    "Printer" : {
        "Method" : "Formatted",
        "Format": "Pat?()\tMatches(fore)\tMatches(back)\tHyper(fore,back)\n"
    }
}
\end{lstlisting}

In hindsight \emph{json} for configuration may not be the best option due to rigidity. Users can often forget to add or remove a comma or forget to add quotes. This suggests that formats such as \emph{rson} or \emph{yaml} would be better choices.

Other problem with configuration files is that they are harder to modify than command-line flags. By mixing command-line flags and configuration files we can get a solution that works better in practice than either of them independently.

One easy way to implement is to add custom syntax into the configuration file:

\begin{lstlisting}
    "Datasets" : {
        "fore" : { "File" : "$argument:default$"
        ...
\end{lstlisting}

Now some command-flags can be interpreted as replacements into the configuration file. Using \cmdline{spexs2 --conf conf.json argument=other} would transform the configuration file into:

\begin{lstlisting}
    "Datasets" : {
        "fore" : { "File" : "other"
        ...
\end{lstlisting}

If no such parameter is given then the default value "main" can be used.

Configuration files are also problematic for running the first time. As a user you need to find a configuration file that suits your needs, then modify it and finally run it. To remedy this problem the application can embed sample configuration files so called "profiles" that can be used directly from the command line. This means you can directly use \cmdline{spexs2 -p=protein input=some.data min-p=1.0}.

\section{Input and Output}

\WIP

\tow{about importance of separating the input reader and output printer from the algorithmic code}

\section{Alphabet and Database}

\WIP

\tow{about problems with large alphabets and datasets}

\section{Pools}

\WIP

There can be different performance characteristics when using a particular implementation.

If we use a fifo queue as the in pool the algorithm does a breadth first search of patterns. This can be problematic since we would need a lot of memory to hold all the patterns in memory.

A lifo queue for input pool is a more reasonable choice for memory problems since we need to hold less patterns in memory.

A priority queue suits for the output pool since we can easily then use some feature to sort the queue.

\section{Query features, interestingness and filters}

When we first described the query features we showed that filters and interestingness are a special case query features. In \emph{spexs2} the features are used to print information about the results.

The filters can be very similar to features in their implementation. For example a filter for pattern length is similar to the pattern length feature.

Although implementing all combinations is possible we can use function composition to avoid such repetition.

Since most of the features implemented could also be used as a interestingness measure we used a simplification for the "Feature" function defintion:

\begin{lstlisting}
type Feature func(q *Query) (float64, string)
\end{lstlisting}

Which means that the function returns two types, a real value and a string. In the implementation there are only few features that return arbitrary types so it was easier to convert it into a string. The only place where such features were needed is for printing. For example one of such features is the representation of the pattern.

By specifying a minimum or a maximum value for a feature we can turn it into a filter. One way to do it is using a lexical closure. For example:

\begin{lstlisting}
func MakeFeatureFilter(fn Feature, min float64, max float64) Filter {
    return func(q *Query) bool {
        v, _ := feature(q)
        return (min <= v) && (v <= max)
    }
}
\end{lstlisting}

In languages which do not support such composition we can also use object composition or function pointers. 

Of course there are some filters that cannot be defined by features hence there is still possibility to make separate filters. Such as disallowing star symbol in the beginning of the pattern.

\section{Synchronized Tree Traversal}

\emph{spexs2} can be seen as a pattern tree traversal algorithm with some extra logic. Implementing search over a tree requires synchronization such that there are only a certain number of workers and that they wouldn't die of starvation.

Without synchronization the parallel version looks like:

\begin{algorithm}[H]
    \caption{Tree traversal}
\begin{algorithmic}[1]
    \Ensure{All nodes in tree get processed with fn}

    \Function{visit}{tree, start, fn, examine?}
        \Let{$unvisited$}{\{ start \})}
        
        \Spawn
            \While{$unvisited$ not empty}
                \Let{$node$}{$unvisited$.take()}
                \State fn($node$)
                \For{ $child \in$ children($node$) }
                    \If{ examine?($child$) }
                        \State $unvisited$.put($child$)
                    \EndIf
                \EndFor
            \EndWhile
        \EndSpawn

        \State{wait for workers}
    \EndFunction
\end{algorithmic}
\end{algorithm}

This would not work correctly with multiple workers since there are race conditions and the workers can die early due to starvation.

The solution is to control worker startup and only terminate workers if all have finished and there are no more items in unvisited set.

\begin{algorithm}[H]
    \caption{Synchronized graph traversal}
\begin{algorithmic}[1]
    \Ensure{All nodes in $graph$ get processed with $fn$}

    \Function{Visit}{graph, start, fn, examine?}
        \Let{added}     {new semaphore(0)}
        \Let{$terminate$} {false}
        \Let{mutex}     {new mutex()}
        \Let{$workers$}   {0}
        \Let{$unvisited$} {\{ start \}}
        \State $added$.signal()
        
        \Spawn
            \While{$true$}
                \State added.wait()
                \State mutex.lock()
                \If{ $terminate$ }
                    \State added.signal()
                    \State mutex.unlock()
                    \State{\textbf{break}}
                \EndIf

                \Let{$node$}{$unvisited$.take()}
                \Let{$workers$}{$workers$ + 1}
                \State mutex.unlock()
                \Statex
                \State fn($node$)
                \Statex
                \For{ $child \in$ children($node$) }
                    \State mutex.lock()
                    \If{ examine?($child$) }
                        \State $unvisited$.put($child$)
                        \State added.signal()
                    \EndIf
                    \State mutex.unlock()
                \EndFor
                \Statex
                \State mutex.lock()
                \Let{$workers$}{$workers - 1$}
                \If{$workers = 0$ and $unvisited = \{\}$}
                    \Let{$terminate$}{true}
                    \State added.signal()
                \EndIf
                \State mutex.unlock()
            \EndWhile
        \EndSpawn

        \State{wait for workers}
    \EndFunction
\end{algorithmic}
\end{algorithm}

We use $mutex$ to protect variables and data structures. Semaphore $added$ tracks how many items are in the $unvisited$ set, if the process finally terminates it is turned into a turnstile on line 31 and 13. Variable $workers$ tracks how many workers are busy.

\section{Debugging}

Seeing how the algorithm works is very useful to get an understanding how the algorithm works. This often can help to either improve the input configuration or debug the program itself. Often this is resolved by adding debug statments.

For example:

\begin{lstlisting}
func Spexs(s *Setup) {
    for q, ok := s.In.Pop(); ok {
        trace("started extending %v", q)
        extended := s.Extend(q)
        trace("extension result %v", extended)
        for qx := range extended {
            if s.Extendable(qx) {
                trace(" > extendable %v" qx)
                s.In.Push(qx)
            }
            if s.Outputtable(qx) {
                trace(" > outputtable %v" qx)
                s.Out.Push(qx)
            }
        }
    }
}
\end{lstlisting}

Such statements make it harder to read the actual code, also it's hard to modify the statements for debugging or provide different ways of debugging.

We can use lexical closures to make it simpler:

\begin{lstlisting}
type Extender func(q Query) []Query

func AddDebuggingStatements(s *Setup) {
    fn := s.Extend
    s.Extend := func(q Query) []Query {
        trace("started extending %v", q)
        extended := fn(q)
        trace("extension result %v", extended)
        
        for qx := range extended {
            trace(" > %v", qx)
            trace(" > extendable %v", s.Extendable(qx))
            trace(" > outputtable %v", s.Outputtable(qx))
        }
        return extended
    }
}

func Spexs(s *Setup) {
    for q, ok := s.In.Pop(); ok {
        extended := s.Extend(q)
        for qx := range extended {
            if s.Extendable(qx) {
                s.In.Push(qx)
            }
            if s.Outputtable(qx) {
                s.Out.Push(qx)
            }
        }
    }
}

func run(){
    S := CreateSpexsSetup()
    AddDebuggingStatements(S)
    Spexs(S)
}
\end{lstlisting}

We have removed the debugging statements from the algorithm. We could define other such "debug statement injectors" that provide different levels of details. This method of course has a slight performance impact due to the additional indirection. This can be extended to provide user interaction and other features.