\chapter{Implementation}

Here we discuss a practical implementation, \emph{spexs2}, for
pattern discovery in sequences.

The actual implementation may need to diverge from the abstract
definition for several reasons; mainly practicality, simplicity and
performance. Many of the operations can be optimized for some 
particular type of datasets and configuration.

In this chapter we will discuss parts of program that the author
considers non-trivial in it's design decisions. Information about 
the full source code is in the Appendix B and C.

\section{Architecture}

The main criteria for designing program have been described in D. Parnas
paper On the Decomposition of Programs. It suggests decomposing into
isolated units and parts that are likely to change together. \cite{Parnas72}

We chose the following decomposition:

\begin{description}
	\item[Configuration] structure for holding the configuration data
	\item[Setup] based on the configuration initializes data-structures and functions for the algorithm
	\item[Reader] reads in the data from files
	\item[Database] a collection of datasets
	\item[Algorithm] the SPEXS2 algorithm
		\item[Pattern] represents a pattern
		\item[Query] stores the pattern with database and pattern
		\item[Set] stores matching positions
		\item[Pool] stores queries
		\item[Extender] drives algorithms extending step
		\item[Feature] computes a value from the Query
		\item[Filter] filters some queries
	\item[Printer] prints the result queries
	\item[Debugging] utilities for the program
\end{description}

It is a trivial decomposition for the algorithm part, since a lot of is derived 
directly from the algorithm definition.

The main criteria was to decompose things based on their behavior, whether there
is a commonality between them or whether they change independently from the other
parts.

\section{Configuration}

One problem with flexible algorithms is that they a lot of ways to be run.
This often would need having tens or hundereds of program flags.
To avoid this problem we decided to use a json file for the program
configuration.

\todo[inline]{Short example of a configuration file.}

To properly represent configuration in a static language we
marshal this file directly to the data-structure. This means we can be
less worried about parsing when setting up our algorithm.

The problem with only using a json file is that when running from
command line it may be more comfortable using flags. To solve this problem
we added replacement strings into the json files that can be given in as
a program argument.

\begin{verbatim}
	"Datasets" : {
		"fore" : { "File" : "$inp$"
	...
\end{verbatim}

When using spexs2 --conf conf.json input=filename the input will be
replaced by filename. Also there is optional default value if one wasn't given.

\section{Setup and Database}

Setup consumes the configuration and based on the values initializes pools; 
creates and combines features and filters; reads in the data; and creates
the printer.

\todo[inline]{Database}

\section{Reader and Printer}

One problem with data is that it comes in many different forms. For example reading in 
words and single letters requires different behaviors.

One thing that may be helpful is supporting different binary formats.

\section{Sets}

Since we need a collection how to store the matching positions it suggests
the need for a set datatype.

If we have predictable distribution we can pack the sets better. 

Although such optimizations can be avoided, if during storing pools the
sets are packed using some compression algorithm.

\section{Pools}

There can be different performance characteristics when using a particular implementation. 
Most importantly to support parallelism they should be ideally lock-free, but we can use locked version as well.

For the pools we have several choices: lifo, fifo or priority.

If we use a fifo queue as the in pool the algorithm does a breadth first search of patterns.
This can be problematic since we would need a lot of memory to hold all the patterns in memory.

A lifo queue for in pool is a more reasonable choice for memory problems since we need to hold less patterns in memory.

A priority queue suits for the out pool since we can easily then use some feature to sort 
the queue and choose only a limited amount. A lock-free priority queue would be preferred
but it has many details to work correctly. \todo{link to lock-free queues}

One simple solution to make priority queue concurrent is to use mutexes when storing or
retrieving values. This would mean that many processes can get locked.

We can use some knowledge about the priority-queue behavior. We know that it usually
has limited-size and the amount of patterns suitable for putting into the output
queue is several magnitudes larger; this means most of the queries put into
the result queue are discarded. 

We know that if the query is worse than the worst in the priority queue, it can
be discarded immediately without doing push/pop. If we allow for that check
to fail once in a while - we can make it mostly lock-free.

\begin{verbatim}
	worst := current-worst
	if worst > new-query {
		exit
	}

	mutex.lock
	pqueue.push(new-query)
	current-worst = pqueue.pop()
	mutex.unlock
\end{verbatim}

Although the worst may already have changed after line 1, the algorithm still only keeps the best results.

\section{Features and Filters}

One problem is that the amount of possible filters it's useful to construct them from some other features. 
Or if we wish to use multiple filters we can combine them.

We can use these features to find out something about the query.
They each feature is defined as:

\begin{verbatim}
type Feature func(q *Query) (float64, string)
\end{verbatim}

Most of features are in $\Re$, but for some there
is some extended information that we may wish to know - hence
the need for additional string value. One of the simplest
is Pattern representation.

Also many of the features are defined in terms of multiple datasets.
We can use a closure to easily define a more generic feature.

Example:

\begin{verbatim}
func Matches(dataset []int) Feature {
	return func(q *Query) (float64, string) {
		matches := countf(q.Pos, dataset)
		return matches, ""
	}
}
\end{verbatim}

Here the Matches function creates a feature function defined
for dataset.

We can use the name in the configuration file as "Matches(fore)".

If a feature returns a floating point value we can easily turn that
into a filter by specifying a minimum or/and maximum value.

For example to give a lower and higher limits to some feature:

\begin{verbatim}
func featureFilter(feature Feature, min float64, max float64) Filter {
	return func(q *Query) bool {
		v, _ := feature(q)
		return (min <= v) && (v <= max)
	}
}
\end{verbatim}

Of course there are some filters that cannot be defined by features hence
there is still possibility to make separate filters. Such as disallowing
star symbol in the beginning of the pattern.

\section{Debugging}

Debugging is a important part of development process hence the need for 
more information how the algorithm is working.

Often this is resolved by adding some debug statments:

\begin{verbatim}
for i := 0; i < 100; i += 1{
	printf("picking")
	a := pick()
	printf("picked %v", a)

	printf("picking")
	b := pick()
	printf("picked %v", b)
	
	out.put(a + b)
}
\end{verbatim}

This can be harmful to the readability of the code. To fix this debugging problem we use closures.

\begin{verbatim}
type PickFunc func()Thing
func debuggable(fn PickFunc) PickFunc {
	return func() Thing {
		printf("start picking")
		p := fn()
		printf("picked %v" p)
		return p
	}
}

pick = debuggable(pick)
for i := 0; i < 100; i += 1{
	a := pick()
	b := pick()
	out.put(a + b)
}
\end{verbatim}

As we can see the algorithm implementation is much more readable and 
we can inject different debugging statements without actually changing the algorithm.

Also we can now change the ways how to add debug info. One of would 
be a full stepwise debugger.

\begin{verbatim}
func debuggable(fn PickFunc) PickFunc {
	return func() Thing {
		mutex.lock()
		p := fn()
		while not continue
			interact with user
		mutex.unlock()
		return p
	}
}
\end{verbatim}