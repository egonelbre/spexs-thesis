\chapter{SPEXS Generalization}
\label{c:generalization}

In this chapter we show how to make SPEXS algorithm more abstract by allowing flexibilty through function composition and finding minimal requirements for the data-structures.

\section{Algorithm}

The algorithm in a more conventional view is:

\begin{algorithm}[H]
	\caption{The spexs2 algorithm}
\begin{algorithmic}[1]
	\Require{$dataset$, $in$ and $out$ are pools, $extend$ is an extender function, $extend?$, $output?$ are filters}
	\Ensure{Patterns satisfying filters and $extender$ are in $out$ pool}
	\Statex
	\Function{spexs2}{dataset, in, out, extend, extend?, output?}
		\State prepare(in, dataset)
		\While{$q \gets $ in.pop()}
			\Let{extended}{extend($q$, dataset)}
			\For{ $qx \in $ extended }
				\If{ extend?($qx$) }
					\State in.push($qx$)
					\If{ output?($qx$) }
						\State out.push($qx$)
					\EndIf
				\EndIf
			\EndFor
		\EndWhile
	\EndFunction
\end{algorithmic}
\end{algorithm}

When the algorithm starts by initializing the \emph{in} pool. The \emph{in} pool shall contain queries which we wish to further examine. In the simplest case this means we create an empty pattern query and put it into the \emph{in} pool. We could also start the process with an already existing pattern.

As the next step we pick a query from the \emph{in} pool for extending. The extending means generating all queries whose pattern size is larger by one. There can be several such queries.

If any of the queries should be further examined as defined by the \emph{extendable} query filter, it will be put into the \emph{in} pool.

If the query is suitable for output as defined by the \emph{outputtable} filter, it will be put into the \emph{out} pool. 

If we extend each pattern at each step by one we guarantee that we examine all the patterns that conform to our criteria as defined by \emph{extendable} filter.

\section{Pools}

Since pools act independently from the rest of the algorithm they are free to reorder, store on disk or even discard the queries, if needed. If we wish to get 100 best results the output pool could immediately discard the bad ones.

We can also use different types of structures as pools. For example using a queue would make it start examining breadth first, using a stack would make it run depth first. We can use priority queue to choose the best queries to reach faster the good results as suggested in "Patterns Discovery from Biosequences"\cite{spexs}.

\section{Filtering}

Filtering allows us to reduce the number of queries we have to examine and allows to select a subset of patterns by some criteria. \eg

Although there is only one filter "function" specified the filter could be a composite of multiple filters.

\begin{exmp}
Pattern length is greater than three and pattern occurs at least 10 times in the dataset can be seen as a single filter that is composed of two filters.
\end{exmp}

\section{Extending}

The extending process is at the core of the algorithm and there are several ways of doing it. The main criteria is that the extending should guarantee that all possible patterns get eventually enumerated.

Extender is analogous to an inductive step. Our base case is formulated by \emph{prepare} step in the SPEXS2 algorithm and the induction steps are carried out by the extender.

\begin{exmp}
We start with an empty query and we know all the locations of it. If our extender generates all the queries where the patterns are longer by 1 then we are guaranteed to enumarate all the patterns.
\end{exmp}

\begin{exmp}
We can start with the empty query and all queries with patterns of length 1. Now if our extender generates queries where the patterns are longer by 2 we can also examine all of the queries.
\end{exmp}

The extender determines which patterns and pattern classes will be generated. We can modify and compose different extenders to get new patterns. Often more complex patterns can adversely affect performance.

\tow{grouping and single pattern generation}

If we visualize the sequences as graphs we can extend it with possible extensions.

\subsection{Sequences}

The simplest case how the next function behaves is when we are only looking for simple sequences -- the alphabet for patterns and sequences is the same.

Let's consider a sequence $ACGCCGATCGC$ and a pattern $CG$.

\begin{figure}[H]
	\input{./diagrams/sequence.tex}
\end{figure}

Initially we have matches only for query $CG$. Then by taking the \emph{next} token from the sequence we can build up querys $CGA$ and $CGC$.

\subsection{Groups}

One common addition in a pattern language is capturing a group of tokens. For example we can use $X = [AC]$ to denote both tokens $A, C$. By adding where either one transitions we can capture such groups in the extension process.\

\begin{figure}[H]
	\input{./diagrams/groups.tex}
\end{figure}

\subsection{Star}

Another possible extension is the \emph{dot-star} or more simply capturing a run of elements. Here we just show the expanded sequence with $*$ symbol.

\begin{figure}[H]
	\input{./diagrams/star.tex}
\end{figure}

Here we immediately notice how the complexity increases by introducing pattern token. \tow{properly} We can skip this intermediary step isn't necessary we can instead extend with $*Y$, where $Y$ is some other token. This means we avoid this single large query and have multiple smaller queries.

\begin{figure}[H]
	\input{./diagrams/star2.tex}
\end{figure}

We can also limit the length of the run.

\begin{figure}[H]
	\input{./diagrams/star3.tex}
\end{figure}

Here we have limited the run length to be either 2 or 3.

\subsection{Optimized groups}

Instead of immediately extending the group tokens we can take the output of an other extender and combine its results. If we have a group token $\gamma$ that contains $tokens(\gamma)$ then the \emph{matches} for such group is $$matches(p\gamma, D) = \bigcup_{t \in tokens(\gamma)} matches(pt, D) $$

\begin{exmp}
A pattern \R{A[CTG]} is located in document $D$ at positions $matches(\R{AC}, D) + matches(\R{AT}, D) + matches(\R{AG}, D)$.
\end{exmp}


\subsection{Optional tokens}

\tow{ combine current matches(q) + ... }

\section{Summary}

The extender was shown to work via graphs, practically it is much more reasonable to minimize it as already mentioned in "Pattern Discovery from Biosequences"\cite{spexs}.

Since the best way to visualize was on graphs suggests that the SPEXS2 algorithm could be potentially extended to work on trees and then on graphs.\hmm{?}

From the previous results we can also derive the minimal requirements for the dataset. First we need to get the initial empty query - which means we should be somehow be able to get all the positions where a pattern could start. The other operator is finding the next position and token from a given position.

To use this generic version of the SPEXS algorithm we need to 1. choose our pool structures, 2. choose our filters, 3. choose our extender and preparation and 4. dataset implementation.
