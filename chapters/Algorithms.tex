\chapter{Approaches to Pattern Discovery}
\label{c:algorithms}

\WIP

\section{Combinatorial and Statistical}



\section{Iterative and Division}



\section{Online and Offline}

The algorithms can be online or offline. Online algorithms take a stream input and process it piece-by-piece without having the entire input available from the start. Offline algorithm can examine the whole data immediately as needed.

Online algorithms respond better to change and can incrementally adjust to new data. This is especially useful when we are working with real-time data, such as network monitoring and financial data analysis.

Offline algorithms can find more complicated patterns and provide more "interesting" results. Of course more complicated patterns require more resources to find.

Pattern discovery algorithms in 


In this chapter we give a overview of different algorithms used for pattern discovery.

\hmm{Reorganize somehow}

\section{Algorithms}

Overview of different combinatorial algorithms.

\section{SPEXS}

SPEXS is an pattern discovery algorithm described in "Pattern Discovery from Biosequences"\cite{spexs}. This algorithm finds patterns from a sequence. We take this as our basis for developing a new parallel algorithm. In this chapter we describe original algorithm so that we can later show the changes made to this algorithm.

We describe the general representation of the SPEXS algorithm. 
The original algorithm was as follows:

\todo[inline]{move algorithm to generalization}

\begin{algorithm}[H]
	\caption{The SPEXS algorithm}
\begin{algorithmic}[1]
	\Require{String $S$, pattern class $\sym{P}$, output criteria, search order, and fitness measure $\sym{F}$}
	\Ensure{Patterns $\pi \in \sym{P}$ fulfilling all criteria, and output in the order of fitness $\sym{F}$}

	\State Convert input sequences into a single sequence
	\State Initiate data structures

	\Let{Root}{new node}
	\Let{Root.label}{$\epsilon$}
	\Let{Root.pos}{(1,2,...,n)}
	\State enqueue($\sym{Q}$, Root, order)

	\While{$N \gets$ dequeue($\sym{Q}$)}
		\State Create all possible extensions $p \in \sym{P}$ of $N$ using $N$.pos and $S$
		\For{ extension $p$ of $N$}
			\If{pattern $p$ and position list $p$.pos fulfill the criteria}
				\Let{$N$.child}{$p$}
				\State calculate $\sym{F}(p,S)$
				\State enqueue($\sym{Q}$,$p$,order)
				\If{$p$ fulfills the output criteria}
					\State store $p$ in output queue $\sym{O}$
				\EndIf
			\EndIf
		\EndFor
	\EndWhile
	\State{Report the list of top-ranking patterns from output queue $\sym{O}$}
\end{algorithmic}
\end{algorithm}

The main idea of the algorithm is that first we generate a 
pattern and a query that matches all possible positions in 
the sequence. We then put this query into a queue for extending.
Extending a query means finding all queries whose patterns length
is longer by 1. If any of the queries is fit, by some criteria,
it will be put into the main queue, for further extension, 
and output queue for possible output.

\subsection{TEIRESIAS}

TEIRESIAS\cite{TEIRESIAS} is an algorithm for the discovery of rigid patterns in biological sequences. \tow{more}

TEIRESIAS operates in two phases: scanning and convolution. Scanning phase identifies elementary patterns that are frequent. During convolution these elementary patterns are combined to make larger patterns.

This method is a divide and conquer method to only consider frequent patterns.

patterns with any symbol 

\tow{more} 

\subsection{Verbumculus}

Verbumculus\cite{Verbumculus} is...

statistical analysis, pattern matching

no complex patterns

\tow{more}

\subsection{MobyDick}

MobyDick\cite{MobyDick}...
statistical prediction of frequent

no complex patterns

\tow{more} 

\subsection{RSAT}

RSAT\cite{RSAT} is ...

matrix based pattern

\tow{more}

\subsection{Other}

\cite{NetworkMotifsDiscovery, GenericMotifSequential}

\section{Reviews}

\cite{CombinatorialSubtle, SurveyDNAMotif, SurveyMotifDiscovery}

\tow{about some reviews}

\section{Problems}

\WIP

Algorithms are fixed and hard to extend with new pattern types, structures and optimizations. Generalization usually comes at the cost of performance and complexity. \tow{more}

Sequential algorithms do not take advantage of multicore processors. \tow{more}

Data that exceeds computer memory can't work efficiently... can't be distributed efficiently. \tow{more}